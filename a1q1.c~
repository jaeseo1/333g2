#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <err.h>
#include <stdbool.h>

#define BUFFER_SIZE 64
#define CHAIN_SIZE 3 // n-chain

static int map[16][16] = {
	{0x7, 0x5, 0x0, 0x4, 0x2, 0x3, 0xb, 0x6, 0xa, 0x8, 0x9, 0xd, 0xc, 0xf, 0xe, 0x1},
	{0x3, 0x8, 0xd, 0xa, 0xc, 0xe, 0xf, 0xb, 0x7, 0x6, 0x4, 0x5, 0x1, 0x2, 0x0, 0x9},
	{0x4, 0x0, 0x3, 0x1, 0xb, 0xa, 0x8, 0x5, 0x9, 0xd, 0xc, 0xe, 0xf, 0x6, 0x7, 0x2},
	{0x9, 0xe, 0x7, 0xc, 0x6, 0x4, 0x5, 0xd, 0x1, 0x0, 0x2, 0x3, 0xb, 0x8, 0xa, 0xf},
	{0x1, 0x3, 0xa, 0x2, 0x8, 0x9, 0xd, 0x0, 0xc, 0xe, 0xf, 0x7, 0x6, 0x5, 0x4, 0xb},
	{0xe, 0x6, 0x5, 0x7, 0x1, 0x0, 0x2, 0xf, 0x3, 0xb, 0xa, 0x8, 0x9, 0xc, 0xd, 0x4},
	{0x2, 0xa, 0x9, 0xb, 0xd, 0xc, 0xe, 0x3, 0xf, 0x7, 0x6, 0x4, 0x5, 0x0, 0x1, 0x8},
	{0x6, 0x1, 0x2, 0x5, 0x3, 0xb, 0xa, 0x4, 0x8, 0x9, 0xd, 0xc, 0xe, 0x7, 0xf, 0x0},
	{0xb, 0x9, 0xc, 0x8, 0xe, 0xf, 0x7, 0xa, 0x6, 0x4, 0x5, 0x1, 0x0, 0x3, 0x2, 0xd},
	{0x0, 0xb, 0x8, 0x3, 0x9, 0xd, 0xc, 0x2, 0xe, 0xf, 0x7, 0x6, 0x4, 0x1, 0x5, 0xa},
	{0x8, 0xc, 0xf, 0xd, 0x7, 0x6, 0x4, 0x9, 0x5, 0x1, 0x0, 0x2, 0x3, 0xa, 0xb, 0xe},
	{0x5, 0x2, 0xb, 0x0, 0xa, 0x8, 0x9, 0x1, 0xd, 0xc, 0xe, 0xf, 0x7, 0x4, 0x6, 0x3},
	{0xd, 0xf, 0x6, 0xe, 0x4, 0x5, 0x1, 0xc, 0x0, 0x2, 0x3, 0xb, 0xa, 0x9, 0x8, 0x7},
	{0xc, 0x7, 0x4, 0xf, 0x5, 0x1, 0x0, 0xe, 0x2, 0x3, 0xb, 0xa, 0x8, 0xd, 0x9, 0x6},
	{0xa, 0xd, 0xe, 0x9, 0xf, 0x7, 0x6, 0x8, 0x4, 0x5, 0x1, 0x0, 0x2, 0xb, 0x3, 0xc},
	{0xf, 0x4, 0x1, 0x6, 0x0, 0x2, 0x3, 0x7, 0xb, 0xa, 0x8, 0x9, 0xd, 0xe, 0xc, 0x5}};

struct chain {
	// an element of chain list.
	// contains the n-chain string, and the number of occurences.
	char chainStr[CHAIN_SIZE];
	int occurence;
};

struct chain makeChain(char *givenStr) {
	// given a string, makes a chain and returns it.
	struct chain newChain;
	strncpy(newChain.chainStr, givenStr, CHAIN_SIZE);
	newChain.occurence = 1;
	return newChain;
}

struct chain* isInList(struct chain *chainList, int chainListIndex, char *str) {
	// checks if the chain with the given str already exists in the list.
	// if it's in the list, return the pointer to the existing chain.
	// return NULL otherwise.
	int searchIndex;
	for (searchIndex = 0; searchIndex < chainListIndex; searchIndex++) {
		if (strcmp(chainList[searchIndex].chainStr, str) == 0) {
			return &chainList[searchIndex];
		}
	}
	return NULL;
}

void addThisChainToList(struct chain *chainList, struct chain givenChain) {
	// write code here
}

int getHigh(int text) {
	// returns the high 4 bits of the given int
	int high;
	high = (text >> 4);
	return high;
}

int getLow(int text) {
	// returns the low 4 bits of the given int
	int low;
	low = (text & 15);
	return low;
}

int main(int argc, char* argv[]) {

	// error check on arguments
	if (argc != 2) {
		fprintf(stderr, "need a ciphertext file\n");
		return(-1);
	}

	// read input file.
	FILE* fp;
	fp = fopen(argv[1], "r");
	if (fp == NULL) {
		fprintf(stderr, "input file is invalid\n");
		return(-1);
	}

	// find n consecutive characters (n-chain) that appear multiple times in the cipher text.
	struct chain *chainList;
	chainList = (struct chain *) malloc(sizeof(struct chain));
	int chainListIndex = 0;
	char buffer[BUFFER_SIZE];
	int bufferIndex;
	while (fgets(buffer, BUFFER_SIZE, fp) != NULL) {
		// note: the code works only for the first buffer.. will have to deal with
		// cipher text longer than the buffer. (will discuss in class or lab)
		for (bufferIndex = 0; bufferIndex < BUFFER_SIZE; bufferIndex++) {
			// the upper bound BUFFER_SIZE is now okay.
			if (strcmp(&buffer[bufferIndex+CHAIN_SIZE], "\0") == 0) {
				// do something if buffer is running out
				// these lines are for test purposes.
				fprintf(stderr, "first buffer ran out\n");
				return(-1);
			}
			char chainStr[CHAIN_SIZE];
			strncpy(chainStr, &buffer[bufferIndex+1], CHAIN_SIZE);
			printf("this chain: %s\n", chainStr); // test line
			struct chain* searchResult = isInList(chainList, chainListIndex, &buffer[bufferIndex]);
			if (searchResult != NULL) {
				printf("hello\n"); //test line
				searchResult->occurence++;
			}
			else {
				// this chain is the 1st instnace.. add to the list.
				// (realloc memory for the chain list if necessary)
				chainListIndex++;
			}
			
			// add each chain to the chainList
			// upper bound of index should be corrected. BUFFER_SIZE is too big.
		}
	}
	
	// analyze the pattern that they appear. (ex. appear every x bytes)
	
	// find the key length and then apply frequency analysis.

	return 0;
}
